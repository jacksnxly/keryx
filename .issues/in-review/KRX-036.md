---
id: "KRX-036"
title: "Fix changelog insertion byte offset for Windows line endings"
type: bug
status: in-review
priority: urgent
labels: ["critical-gap", "bug"]
created: "2026-01-26"
updated: "2026-01-26"
assignee: null
---

# Fix changelog insertion byte offset for Windows line endings

## Problem
The `find_insertion_point` function assumes Unix line endings (`\n` = 1 byte), but on Windows lines end with `\r\n` (2 bytes). This causes incorrect byte offset calculation when inserting new version sections.

## Current Behavior
On Windows, the calculated byte position is wrong because each line's length is assumed to include only 1 byte for the line ending, when it's actually 2 bytes.

```rust
let byte_pos: usize =
    lines.iter().take(i + j + 1).map(|l| l.len() + 1).sum();
```

## Expected Behavior
Byte offset calculation should work correctly regardless of line ending style (Unix `\n` or Windows `\r\n`).

## Steps to Reproduce
1. Create a changelog file on Windows with CRLF line endings
2. Run `keryx` to add a new version section
3. Observe corrupted/misplaced changelog content

**Environment:** Windows (any version with CRLF line endings)

## Acceptance Criteria
- [x] Changelog insertion works correctly on Windows with CRLF line endings
- [x] Changelog insertion continues to work on Unix with LF line endings
- [x] Add test with CRLF line endings to prevent regression

## Technical Notes
**File:** `src/changelog/parser.rs:99-101`

Options to fix:
1. Normalize line endings before processing (convert CRLF to LF)
2. Track byte offsets from the original content instead of reconstructing
3. Detect line ending style and adjust calculation accordingly

---

## Resolution

**Completed:** 2026-01-26

### Approach
Used **Option 1: Normalize line endings before processing**. This is the approach used by rust-analyzer and is recommended as the simplest and most robust solution. Both `find_insertion_point` and `write_changelog` now normalize CRLF to LF before processing, ensuring consistent byte offset calculations.

### Changes Made
- `src/changelog/parser.rs`: Added CRLF→LF normalization at start of `find_insertion_point()`. Updated doc comment to document this behavior.
- `src/changelog/writer.rs`: Added CRLF→LF normalization in `write_changelog()` before slicing content with byte offset.
- `src/changelog/parser.rs` (tests): Added 4 unit tests for CRLF handling
- `tests/changelog_test.rs`: Added 3 integration tests for CRLF handling

### Research Sources
- [Rust str::lines() documentation](https://doc.rust-lang.org/std/primitive.str.html#method.lines) - confirms lines() strips line endings
- [RFC 1212 - Line Endings](https://rust-lang.github.io/rfcs/1212-line-endings.html) - official Rust RFC
- [rust-analyzer line_index.rs](https://github.com/rust-lang/rust-analyzer/blob/master/crates/rust-analyzer/src/line_index.rs) - production implementation using normalization approach

### Testing
- [x] Build passes (cargo build --release)
- [x] All 203 tests pass (cargo test)
- [x] 7 new CRLF-specific tests added and passing:
  - `test_find_insertion_point_crlf_with_unreleased`
  - `test_find_insertion_point_crlf_no_unreleased`
  - `test_find_insertion_point_crlf_only_unreleased`
  - `test_find_insertion_point_mixed_line_endings`
  - `test_find_insertion_point_crlf` (integration)
  - `test_write_changelog_with_crlf_line_endings` (integration)
  - `test_write_changelog_with_crlf_and_unreleased` (integration)

### Notes
- Output changelogs will use LF line endings (cross-platform standard)
- Users who need CRLF can configure git with `.gitattributes`

---
*Solved by Claude Code*
