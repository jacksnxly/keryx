---
id: "KRX-006"
title: "Fix background update thread output interleaving"
type: bug
status: done
priority: low
labels: [ux, concurrency]
created: "2026-01-25"
updated: "2026-01-25"
started: "2026-01-25"
assignee: null
---

# Fix background update thread output interleaving

## Problem
The background update check thread can write to stderr while the main thread is also printing, causing garbled console output.

## Current Behavior
In `src/main.rs:93-105`:
```rust
fn check_for_updates_background(verbose: bool) {
    std::thread::spawn(move || {
        if let Err(e) = check_and_notify_update() {
            if verbose {
                debug!("Update check failed: {}", e);
            }
        }
    });
}
```
The spawned thread writes to stderr without synchronization.

## Expected Behavior
Update notifications should not interleave with main program output.

## Acceptance Criteria
- [x] Update notification appears at a controlled time
- [x] No interleaved/garbled output
- [x] Update check remains non-blocking

## Technical Notes
**File:** `src/main.rs:93-105`

Options:
1. Use a channel to communicate update notification back to main thread
2. Store result and print at end of main program
3. Use proper synchronization for stderr access
4. Print update notification only after main output is complete

---

## Resolution

**Completed:** 2026-01-25

### Approach
Implemented option 1 (channel-based communication) combined with option 4 (print after main output). Used Rust's standard library `std::sync::mpsc` channel to send the update check result from the background thread to the main thread, then print the notification at the very end of program execution.

### Changes Made
- `src/main.rs`: Refactored update check system
  - Added `UpdateResult` struct to hold update check result
  - Added `UpdateChecker` struct with `start()` and `maybe_notify()` methods
  - Replaced fire-and-forget `check_for_updates_background()` with channel-based pattern
  - Split `check_and_notify_update()` into `check_for_update()` (returns bool) and `print_update_notification()` (prints banner)
  - Updated `main()` to store command result, call `maybe_notify()` at very end

### Key Implementation Details
- `UpdateChecker::start(verbose)` spawns thread, creates channel, returns immediately
- `UpdateChecker::maybe_notify()` uses `try_recv()` for non-blocking check
- Update notification only prints after all main program output completes
- Errors handled gracefully (logged at debug level in verbose mode)
- Thread handle kept to prevent detachment

### Research Sources
- [std::sync::mpsc - Rust Standard Library](https://doc.rust-lang.org/std/sync/mpsc/)
- [JoinHandle in std::thread](https://doc.rust-lang.org/std/thread/struct.JoinHandle.html)
- [Join Your Threads - matklad](https://matklad.github.io/2019/08/23/join-your-threads.html)

### Testing
- [x] Build passes (`cargo build`)
- [x] 91 tests pass (`cargo test`)
- [x] Clippy passes (4 pre-existing style warnings unrelated to this fix)
- [ ] Manual testing required

---
*Solved by Claude Code*
