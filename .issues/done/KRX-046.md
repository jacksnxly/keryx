---
id: "KRX-046"
title: "Add integration test for Claude error recovery"
type: task
status: done
priority: high
labels: ["testing", "critical-gap"]
created: "2026-01-26"
updated: "2026-01-26"
assignee: null
---

# Add integration test for Claude error recovery

## Problem
While there are unit tests for retry logic using mocks, there's no integration test verifying that the actual Claude subprocess error handling works end-to-end. The error recovery path is untested.

## Current State
- Unit tests exist for retry logic in `retry.rs`
- Subprocess tests test patterns using shell commands
- No test for `run_claude` -> `parse_claude_response` -> retry integration

## Desired State
Integration tests that verify the complete error recovery flow works correctly.

## Acceptance Criteria
- [x] Test: Claude returning invalid JSON triggers retry
- [x] Test: Claude timeout produces clear error message
- [x] Test: All retries exhausted includes the last error for debugging
- [x] Test: Partial/malformed JSON is handled gracefully

## Technical Notes
**Files:**
- `src/claude/retry.rs`
- `src/claude/subprocess.rs`

Consider using a mock Claude binary or environment variable to simulate failures. The `KERYX_CLAUDE_TIMEOUT` env var could be used to test timeout behavior.

---

## Resolution

**Completed:** 2026-01-26

### Approach
Created integration tests that use a `ScriptExecutor` implementation of `ClaudeExecutor` trait. This executor runs real shell scripts as subprocesses to simulate various Claude CLI failure modes, testing the actual subprocess -> retry flow end-to-end.

This approach was chosen over PATH injection because:
1. The `which::which` crate doesn't respect PATH changes in child processes
2. Testing through the `ClaudeExecutor` trait interface tests the actual retry logic
3. Shell scripts can simulate exact failure modes reproducibly

### Changes Made
- `tests/claude_integration_test.rs`: New integration test file with 8 tests:
  - `test_invalid_json_triggers_retry` - Verifies retry on invalid JSON (AC1)
  - `test_timeout_produces_clear_error` - Verifies timeout handling (AC2)
  - `test_retries_exhausted_includes_last_error` - Verifies error preservation (AC3)
  - `test_partial_json_handled_gracefully` - Verifies malformed JSON handling (AC4)
  - `test_success_on_first_attempt` - Baseline success case
  - `test_recovery_after_transient_failures` - Verifies recovery after 2 failures
  - `test_nonzero_exit_captures_detailed_stderr` - Verifies stderr capture
  - `test_is_error_flag_handled` - Verifies Claude error envelope handling

### Research Sources
- [Testing - Command Line Applications in Rust](https://rust-cli.github.io/book/tutorial/testing.html)
- [test-binary crate documentation](https://docs.rs/test-binary/latest/test_binary/)
- [assert_cmd crate documentation](https://docs.rs/assert_cmd)

### Testing
- [x] Build passes (`cargo build --release`)
- [x] All 208 tests pass (`cargo test`)
- [x] New integration tests specifically verify error recovery paths

---
*Solved by Claude Code*
