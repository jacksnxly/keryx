---
id: "KRX-018"
title: "Fix UTF-8 truncation bug in PR body handling"
type: bug
status: done
priority: urgent
labels: ["critical-gap", "bug", "security"]
created: "2026-01-25"
updated: "2026-01-25"
assignee: null
---

# Fix UTF-8 truncation bug in PR body handling

## Problem
PR body truncation in `src/github/prs.rs` slices at a byte position which can panic if the position falls in the middle of a multi-byte UTF-8 character. For example, Japanese characters take 3 bytes, and slicing at byte 10,000 could cut a character in half.

## Current Behavior
```rust
let body = pr.body.map(|b| {
    if b.len() > MAX_BODY_LENGTH {
        format!("{}... [truncated]", &b[..MAX_BODY_LENGTH])
    } else {
        b
    }
});
```

This will panic with: `byte index X is not a char boundary` when `MAX_BODY_LENGTH` falls within a multi-byte character.

## Expected Behavior
Truncation should be character-safe, never cutting multi-byte characters in half.

## Steps to Reproduce
1. Create a PR with a body containing non-ASCII characters (Japanese, emoji, etc.)
2. Ensure the body is longer than 10KB
3. Run keryx to fetch PRs
4. Observe panic on truncation

**Environment:** Any repository with non-ASCII PR content

## Acceptance Criteria
- [x] PR body truncation never panics on multi-byte characters
- [x] Truncation finds nearest valid character boundary
- [x] Truncated content is valid UTF-8
- [x] Add unit test for multi-byte truncation edge case

## Technical Notes
**File:** `src/github/prs.rs:120-126`

**Recommended fix:** Use character-safe truncation like in `prompt.rs:154-160`:
```rust
let body = pr.body.map(|b| {
    if b.len() > MAX_BODY_LENGTH {
        let mut truncated: String = b.chars().take(MAX_BODY_LENGTH).collect();
        // Ensure we're at a char boundary (for grapheme clusters)
        while !truncated.is_char_boundary(truncated.len()) && !truncated.is_empty() {
            truncated.pop();
        }
        format!("{}... [truncated]", truncated)
    } else {
        b
    }
});
```

**Alternative:** Use the `unicode-segmentation` crate for proper grapheme cluster handling.

**Test case:**
```rust
#[test]
fn test_truncate_multibyte() {
    let body = "„ÅÇ".repeat(5000); // 3 bytes each = 15000 bytes
    // Should not panic
    let truncated = truncate_body(&body, 10000);
    assert!(truncated.is_valid_utf8());
}
```

---

## Resolution

**Completed:** 2026-01-25

### Approach
Created a dedicated `truncate_body()` helper function that safely truncates strings by finding the nearest valid character boundary using `is_char_boundary()`. This prevents panics when truncating multi-byte UTF-8 characters (Japanese, emoji, etc.).

### Changes Made
- `src/github/prs.rs:24-36`: Added `truncate_body()` helper function that:
  - Returns string unchanged if within max length
  - Searches backwards from max_len to find valid UTF-8 boundary
  - Appends "... [truncated]" suffix
- `src/github/prs.rs:131`: Replaced inline truncation with `truncate_body()` call
- `src/github/prs.rs:246-297`: Added 7 comprehensive unit tests:
  - `test_truncate_body_short_string` - no truncation needed
  - `test_truncate_body_exact_length` - boundary case
  - `test_truncate_body_ascii_overflow` - basic ASCII truncation
  - `test_truncate_body_multibyte_japanese` - 3-byte characters
  - `test_truncate_body_multibyte_emoji` - 4-byte characters
  - `test_truncate_body_mixed_content` - ASCII + multi-byte mix
  - `test_truncate_body_large_multibyte` - 15KB of Japanese text

### Testing
- [x] Build passes (`cargo build`)
- [x] All 146 tests pass (`cargo test`)
- [x] New truncation tests verify UTF-8 safety

---
*Solved by Claude Code*
