---
id: "KRX-018"
title: "Fix UTF-8 truncation bug in PR body handling"
type: bug
status: backlog
priority: urgent
labels: ["critical-gap", "bug", "security"]
created: "2026-01-25"
updated: "2026-01-25"
assignee: null
---

# Fix UTF-8 truncation bug in PR body handling

## Problem
PR body truncation in `src/github/prs.rs` slices at a byte position which can panic if the position falls in the middle of a multi-byte UTF-8 character. For example, Japanese characters take 3 bytes, and slicing at byte 10,000 could cut a character in half.

## Current Behavior
```rust
let body = pr.body.map(|b| {
    if b.len() > MAX_BODY_LENGTH {
        format!("{}... [truncated]", &b[..MAX_BODY_LENGTH])
    } else {
        b
    }
});
```

This will panic with: `byte index X is not a char boundary` when `MAX_BODY_LENGTH` falls within a multi-byte character.

## Expected Behavior
Truncation should be character-safe, never cutting multi-byte characters in half.

## Steps to Reproduce
1. Create a PR with a body containing non-ASCII characters (Japanese, emoji, etc.)
2. Ensure the body is longer than 10KB
3. Run keryx to fetch PRs
4. Observe panic on truncation

**Environment:** Any repository with non-ASCII PR content

## Acceptance Criteria
- [ ] PR body truncation never panics on multi-byte characters
- [ ] Truncation finds nearest valid character boundary
- [ ] Truncated content is valid UTF-8
- [ ] Add unit test for multi-byte truncation edge case

## Technical Notes
**File:** `src/github/prs.rs:120-126`

**Recommended fix:** Use character-safe truncation like in `prompt.rs:154-160`:
```rust
let body = pr.body.map(|b| {
    if b.len() > MAX_BODY_LENGTH {
        let mut truncated: String = b.chars().take(MAX_BODY_LENGTH).collect();
        // Ensure we're at a char boundary (for grapheme clusters)
        while !truncated.is_char_boundary(truncated.len()) && !truncated.is_empty() {
            truncated.pop();
        }
        format!("{}... [truncated]", truncated)
    } else {
        b
    }
});
```

**Alternative:** Use the `unicode-segmentation` crate for proper grapheme cluster handling.

**Test case:**
```rust
#[test]
fn test_truncate_multibyte() {
    let body = "„ÅÇ".repeat(5000); // 3 bytes each = 15000 bytes
    // Should not panic
    let truncated = truncate_body(&body, 10000);
    assert!(truncated.is_valid_utf8());
}
```
